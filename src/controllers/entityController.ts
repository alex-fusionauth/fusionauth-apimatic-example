/**
 * FusionAuth APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ErrorsError } from '../errors/errorsError';
import {
  EntityGrantRequest,
  entityGrantRequestSchema,
} from '../models/entityGrantRequest';
import {
  EntityGrantResponse,
  entityGrantResponseSchema,
} from '../models/entityGrantResponse';
import {
  EntityGrantSearchRequest,
  entityGrantSearchRequestSchema,
} from '../models/entityGrantSearchRequest';
import {
  EntityGrantSearchResponse,
  entityGrantSearchResponseSchema,
} from '../models/entityGrantSearchResponse';
import { EntityRequest, entityRequestSchema } from '../models/entityRequest';
import { EntityResponse, entityResponseSchema } from '../models/entityResponse';
import {
  EntitySearchRequest,
  entitySearchRequestSchema,
} from '../models/entitySearchRequest';
import {
  EntitySearchResponse,
  entitySearchResponseSchema,
} from '../models/entitySearchResponse';
import {
  EntityTypeRequest,
  entityTypeRequestSchema,
} from '../models/entityTypeRequest';
import {
  EntityTypeResponse,
  entityTypeResponseSchema,
} from '../models/entityTypeResponse';
import {
  EntityTypeSearchRequest,
  entityTypeSearchRequestSchema,
} from '../models/entityTypeSearchRequest';
import {
  EntityTypeSearchResponse,
  entityTypeSearchResponseSchema,
} from '../models/entityTypeSearchResponse';
import { optional, string } from '../schema';
import { BaseController } from './baseController';

export class EntityController extends BaseController {
  /**
   * Deletes the Entity for the given Id.
   *
   * @param entityId              The Id of the Entity to delete.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async deleteEntity(
    entityId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/entity/${mapped.entityId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Retrieves the Entity for the given Id.
   *
   * @param entityId              The Id of the Entity.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveEntity(
    entityId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/entity/${mapped.entityId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityResponseSchema, requestOptions);
  }

  /**
   * Updates the Entity with the given Id.
   *
   * @param entityId              The Id of the Entity to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                      Only required when there is more than one tenant and the API
   *                                                      key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async updateEntity(
    entityId: string,
    xFusionAuthTenantId?: string,
    body?: EntityRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(entityRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/${mapped.entityId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityResponseSchema, requestOptions);
  }

  /**
   * Creates an Entity. You can optionally specify an Id for the Entity. If not provided one will be
   * generated.
   *
   * @param entityId              (Optional) The Id for the Entity. If not provided a secure
   *                                                      random UUID will be generated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                      Only required when there is more than one tenant and the API
   *                                                      key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async createEntity(
    entityId: string,
    xFusionAuthTenantId?: string,
    body?: EntityRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(entityRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/${mapped.entityId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityResponseSchema, requestOptions);
  }

  /**
   * Updates the Entity Type with the given Id.
   *
   * @param entityTypeId The Id of the Entity Type to update.
   * @param body
   * @return Response from the API call
   */
  async updateEntityType(
    entityTypeId: string,
    body?: EntityTypeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      entityTypeId: [entityTypeId, string()],
      body: [body, optional(entityTypeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }

  /**
   * Creates a new permission for an entity type. You must specify the Id of the entity type you are
   * creating the permission for. You can optionally specify an Id for the permission inside the
   * EntityTypePermission object itself, if not provided one will be generated.
   *
   * @param entityTypeId The Id of the entity type to create the permission on.
   * @param permissionId (Optional) The Id of the permission. If not provided a secure
   *                                                 random UUID will be generated.
   * @param body
   * @return Response from the API call
   */
  async createEntityTypePermission(
    entityTypeId: string,
    permissionId: string,
    body?: EntityTypeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      entityTypeId: [entityTypeId, string()],
      permissionId: [permissionId, string()],
      body: [body, optional(entityTypeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}/permission/${mapped.permissionId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }

  /**
   * Hard deletes a permission. This is a dangerous operation and should not be used in most
   * circumstances. This permanently removes the given permission from all grants that had it.
   *
   * @param entityTypeId The Id of the entityType the the permission belongs to.
   * @param permissionId The Id of the permission to delete.
   * @return Response from the API call
   */
  async deleteEntityTypePermission(
    entityTypeId: string,
    permissionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      entityTypeId: [entityTypeId, string()],
      permissionId: [permissionId, string()],
    });
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}/permission/${mapped.permissionId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Deletes an Entity Grant for the given User or Entity.
   *
   * @param entityId              The Id of the Entity that the Entity Grant is being deleted for.
   * @param recipientEntityId     (Optional) The Id of the Entity that the Entity Grant is for.
   * @param userId                (Optional) The Id of the User that the Entity Grant is for.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async deleteEntityGrant(
    entityId: string,
    recipientEntityId?: string,
    userId?: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      recipientEntityId: [recipientEntityId, optional(string())],
      userId: [userId, optional(string())],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('recipientEntityId', mapped.recipientEntityId);
    req.query('userId', mapped.userId);
    req.appendTemplatePath`/api/entity/${mapped.entityId}/grant`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Retrieves the entities for the given ids. If any Id is invalid, it is ignored.
   *
   * @param ids The entity ids to search for.
   * @return Response from the API call
   */
  async searchEntitiesByIds(
    ids?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntitySearchResponse>> {
    const req = this.createRequest('GET', '/api/entity/search');
    const mapped = req.prepareArgs({ ids: [ids, optional(string())] });
    req.query('ids', mapped.ids);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entitySearchResponseSchema, requestOptions);
  }

  /**
   * Creates a Entity Type. You can optionally specify an Id for the Entity Type, if not provided one
   * will be generated.
   *
   * @param entityTypeId (Optional) The Id for the Entity Type. If not provided a secure
   *                                                 random UUID will be generated.
   * @param body
   * @return Response from the API call
   */
  async createEntityType(
    entityTypeId: string,
    body?: EntityTypeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      entityTypeId: [entityTypeId, string()],
      body: [body, optional(entityTypeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }

  /**
   * Deletes the Entity Type for the given Id.
   *
   * @param entityTypeId The Id of the Entity Type to delete.
   * @return Response from the API call
   */
  async deleteEntityType(
    entityTypeId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ entityTypeId: [entityTypeId, string()] });
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Retrieves the Entity Type for the given Id.
   *
   * @param entityTypeId The Id of the Entity Type.
   * @return Response from the API call
   */
  async retrieveEntityType(
    entityTypeId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ entityTypeId: [entityTypeId, string()] });
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }

  /**
   * Retrieves an Entity Grant for the given Entity and User/Entity.
   *
   * @param entityId              The Id of the Entity.
   * @param recipientEntityId     (Optional) The Id of the Entity that the Entity Grant is for.
   * @param userId                (Optional) The Id of the User that the Entity Grant is for.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveEntityGrant(
    entityId: string,
    recipientEntityId?: string,
    userId?: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityGrantResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      recipientEntityId: [recipientEntityId, optional(string())],
      userId: [userId, optional(string())],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('recipientEntityId', mapped.recipientEntityId);
    req.query('userId', mapped.userId);
    req.appendTemplatePath`/api/entity/${mapped.entityId}/grant`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityGrantResponseSchema, requestOptions);
  }

  /**
   * Searches entities with the specified criteria and pagination.
   *
   * @param body
   * @return Response from the API call
   */
  async searchEntities(
    body?: EntitySearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntitySearchResponse>> {
    const req = this.createRequest('POST', '/api/entity/search');
    const mapped = req.prepareArgs({
      body: [body, optional(entitySearchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entitySearchResponseSchema, requestOptions);
  }

  /**
   * Searches the entity types with the specified criteria and pagination.
   *
   * @param body
   * @return Response from the API call
   */
  async searchEntityTypes(
    body?: EntityTypeSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeSearchResponse>> {
    const req = this.createRequest('POST', '/api/entity/type/search');
    const mapped = req.prepareArgs({
      body: [body, optional(entityTypeSearchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeSearchResponseSchema, requestOptions);
  }

  /**
   * Updates, via PATCH, the Entity Type with the given Id.
   *
   * @param entityTypeId The Id of the Entity Type to update.
   * @param body
   * @return Response from the API call
   */
  async patchEntityType(
    entityTypeId: string,
    body?: EntityTypeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      entityTypeId: [entityTypeId, string()],
      body: [body, optional(entityTypeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }

  /**
   * Updates the permission with the given Id for the entity type.
   *
   * @param entityTypeId The Id of the entityType that the permission belongs to.
   * @param permissionId The Id of the permission to update.
   * @param body
   * @return Response from the API call
   */
  async updateEntityTypePermission(
    entityTypeId: string,
    permissionId: string,
    body?: EntityTypeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      entityTypeId: [entityTypeId, string()],
      permissionId: [permissionId, string()],
      body: [body, optional(entityTypeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/type/${mapped.entityTypeId}/permission/${mapped.permissionId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }

  /**
   * Creates or updates an Entity Grant. This is when a User/Entity is granted permissions to an Entity.
   *
   * @param entityId              The Id of the Entity that the User/Entity is being
   *                                                           granted access to.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async upsertEntityGrant(
    entityId: string,
    xFusionAuthTenantId?: string,
    body?: EntityGrantRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      entityId: [entityId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(entityGrantRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/entity/${mapped.entityId}/grant`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Searches Entity Grants with the specified criteria and pagination.
   *
   * @param body
   * @return Response from the API call
   */
  async searchEntityGrants(
    body?: EntityGrantSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityGrantSearchResponse>> {
    const req = this.createRequest('POST', '/api/entity/grant/search');
    const mapped = req.prepareArgs({
      body: [body, optional(entityGrantSearchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityGrantSearchResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the Entity Types.
   *
   * @return Response from the API call
   */
  async retrieveEntityTypes(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EntityTypeResponse>> {
    const req = this.createRequest('GET', '/api/entity/type');
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(entityTypeResponseSchema, requestOptions);
  }
}
