/**
 * FusionAuth APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import { ErrorsError } from '../errors/errorsError';
import {
  ApplicationOAuthScopeRequest,
  applicationOAuthScopeRequestSchema,
} from '../models/applicationOAuthScopeRequest';
import {
  ApplicationOAuthScopeResponse,
  applicationOAuthScopeResponseSchema,
} from '../models/applicationOAuthScopeResponse';
import {
  ApplicationRequest,
  applicationRequestSchema,
} from '../models/applicationRequest';
import {
  ApplicationResponse,
  applicationResponseSchema,
} from '../models/applicationResponse';
import {
  ApplicationSearchRequest,
  applicationSearchRequestSchema,
} from '../models/applicationSearchRequest';
import {
  ApplicationSearchResponse,
  applicationSearchResponseSchema,
} from '../models/applicationSearchResponse';
import {
  OAuthConfigurationResponse,
  oAuthConfigurationResponseSchema,
} from '../models/oAuthConfigurationResponse';
import { optional, string } from '../schema';
import { BaseController } from './baseController';

export class ApplicationController extends BaseController {
  /**
   * Creates an application. You can optionally specify an Id for the application, if not provided one
   * will be generated.
   *
   * @param applicationId         (Optional) The Id to use for the application. If not
   *                                                           provided a secure random UUID will be generated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async createApplication(
    applicationId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Hard deletes an application role. This is a dangerous operation and should not be used in most
   * circumstances. This permanently removes the given role from all users that had it.
   *
   * @param applicationId         The Id of the application that the role belongs to.
   * @param roleId                The Id of the role to delete.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async deleteApplicationRole(
    applicationId: string,
    roleId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      roleId: [roleId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/role/${mapped.roleId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Updates the application role with the given Id for the application.
   *
   * @param applicationId         The Id of the application that the role belongs to.
   * @param roleId                The Id of the role to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async updateApplicationRole(
    applicationId: string,
    roleId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      roleId: [roleId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/role/${mapped.roleId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the applications that are currently inactive.
   *
   * @param inactive
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveInactiveApplications(
    inactive?: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('GET', '/api/application');
    const mapped = req.prepareArgs({
      inactive: [inactive, optional(string())],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('inactive', mapped.inactive);
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Hard deletes an application. This is a dangerous operation and should not be used in most
   * circumstances. This will delete the application, any registrations for that application, metrics and
   * reports for the application, all the roles for the application, and any other data associated with
   * the application. This operation could take a very long time, depending on the amount of data in your
   * database. OR Deactivates the application with the given Id.
   *
   * @param applicationId         The Id of the application to delete.
   * @param hardDelete
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async deleteApplicationdeactivateApplication(
    applicationId: string,
    hardDelete?: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      hardDelete: [hardDelete, optional(string())],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('hardDelete', mapped.hardDelete);
    req.appendTemplatePath`/api/application/${mapped.applicationId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Updates the application with the given Id. OR Reactivates the application with the given Id.
   *
   * @param applicationId         The Id of the application to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param reactivate
   * @param body
   * @return Response from the API call
   */
  async updateApplicationreactivateApplication(
    applicationId: string,
    xFusionAuthTenantId?: string,
    reactivate?: string,
    body?: ApplicationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      reactivate: [reactivate, optional(string())],
      body: [body, optional(applicationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('reactivate', mapped.reactivate);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Retrieves the application for the given Id or all the applications if the Id is null.
   *
   * @param applicationId         (Optional) The application id.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveApplication(
    applicationId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/application/${mapped.applicationId}`;
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Creates a new custom OAuth scope for an application. You must specify the Id of the application you
   * are creating the scope for. You can optionally specify an Id for the OAuth scope on the URL, if not
   * provided one will be generated.
   *
   * @param applicationId         The Id of the application to create the OAuth
   *                                                                     scope on.
   * @param scopeId               (Optional) The Id of the OAuth scope. If not
   *                                                                     provided a secure random UUID will be
   *                                                                     generated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope
   *                                                                     this API request. Only required when there is
   *                                                                     more than one tenant and the API key is not
   *                                                                     tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async createOAuthScope(
    applicationId: string,
    scopeId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationOAuthScopeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationOAuthScopeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      scopeId: [scopeId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationOAuthScopeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/scope/${mapped.scopeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationOAuthScopeResponseSchema, requestOptions);
  }

  /**
   * Hard deletes a custom OAuth scope. OAuth workflows that are still requesting the deleted OAuth scope
   * may fail depending on the application's unknown scope policy.
   *
   * @param applicationId         The Id of the application that the OAuth scope belongs to.
   * @param scopeId               The Id of the OAuth scope to delete.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async deleteOAuthScope(
    applicationId: string,
    scopeId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      scopeId: [scopeId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/scope/${mapped.scopeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Updates, via PATCH, the custom OAuth scope with the given Id for the application.
   *
   * @param applicationId         The Id of the application that the OAuth
   *                                                                     scope belongs to.
   * @param scopeId               The Id of the OAuth scope to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope
   *                                                                     this API request. Only required when there is
   *                                                                     more than one tenant and the API key is not
   *                                                                     tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async patchOAuthScope(
    applicationId: string,
    scopeId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationOAuthScopeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationOAuthScopeResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      scopeId: [scopeId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationOAuthScopeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/scope/${mapped.scopeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationOAuthScopeResponseSchema, requestOptions);
  }

  /**
   * Retrieves the Oauth2 configuration for the application for the given Application Id.
   *
   * @param applicationId         The Id of the Application to retrieve OAuth configuration.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveOauthConfiguration(
    applicationId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<OAuthConfigurationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/oauth-configuration`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(oAuthConfigurationResponseSchema, requestOptions);
  }

  /**
   * Updates, via PATCH, the application with the given Id.
   *
   * @param applicationId         The Id of the application to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async patchApplication(
    applicationId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Updates, via PATCH, the application role with the given Id for the application.
   *
   * @param applicationId         The Id of the application that the role belongs to.
   * @param roleId                The Id of the role to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async patchApplicationRole(
    applicationId: string,
    roleId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      roleId: [roleId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/role/${mapped.roleId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Creates a new role for an application. You must specify the Id of the application you are creating
   * the role for. You can optionally specify an Id for the role inside the ApplicationRole object itself,
   * if not provided one will be generated.
   *
   * @param applicationId         The Id of the application to create the role on.
   * @param roleId                (Optional) The Id of the role. If not provided a secure
   *                                                           random UUID will be generated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async createApplicationRole(
    applicationId: string,
    roleId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      roleId: [roleId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/role/${mapped.roleId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationResponseSchema, requestOptions);
  }

  /**
   * Retrieves a custom OAuth scope.
   *
   * @param applicationId         The Id of the application that the OAuth scope belongs to.
   * @param scopeId               The Id of the OAuth scope to retrieve.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveOAuthScope(
    applicationId: string,
    scopeId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationOAuthScopeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      scopeId: [scopeId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/scope/${mapped.scopeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationOAuthScopeResponseSchema, requestOptions);
  }

  /**
   * Updates the OAuth scope with the given Id for the application.
   *
   * @param applicationId         The Id of the application that the OAuth
   *                                                                     scope belongs to.
   * @param scopeId               The Id of the OAuth scope to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope
   *                                                                     this API request. Only required when there is
   *                                                                     more than one tenant and the API key is not
   *                                                                     tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async updateOAuthScope(
    applicationId: string,
    scopeId: string,
    xFusionAuthTenantId?: string,
    body?: ApplicationOAuthScopeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationOAuthScopeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, string()],
      scopeId: [scopeId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(applicationOAuthScopeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/application/${mapped.applicationId}/scope/${mapped.scopeId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationOAuthScopeResponseSchema, requestOptions);
  }

  /**
   * Searches applications with the specified criteria and pagination.
   *
   * @param body
   * @return Response from the API call
   */
  async searchApplications(
    body?: ApplicationSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationSearchResponse>> {
    const req = this.createRequest('POST', '/api/application/search');
    const mapped = req.prepareArgs({
      body: [body, optional(applicationSearchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(applicationSearchResponseSchema, requestOptions);
  }
}
