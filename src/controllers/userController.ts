/**
 * FusionAuth APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import { ErrorsError } from '../errors/errorsError';
import { ActionRequest, actionRequestSchema } from '../models/actionRequest';
import { ActionResponse, actionResponseSchema } from '../models/actionResponse';
import {
  ChangePasswordRequest,
  changePasswordRequestSchema,
} from '../models/changePasswordRequest';
import {
  ChangePasswordResponse,
  changePasswordResponseSchema,
} from '../models/changePasswordResponse';
import {
  FamilyEmailRequest,
  familyEmailRequestSchema,
} from '../models/familyEmailRequest';
import { FamilyRequest, familyRequestSchema } from '../models/familyRequest';
import { FamilyResponse, familyResponseSchema } from '../models/familyResponse';
import {
  ForgotPasswordRequest,
  forgotPasswordRequestSchema,
} from '../models/forgotPasswordRequest';
import {
  ForgotPasswordResponse,
  forgotPasswordResponseSchema,
} from '../models/forgotPasswordResponse';
import { ImportRequest, importRequestSchema } from '../models/importRequest';
import {
  PendingResponse,
  pendingResponseSchema,
} from '../models/pendingResponse';
import {
  RecentLoginResponse,
  recentLoginResponseSchema,
} from '../models/recentLoginResponse';
import {
  RefreshTokenImportRequest,
  refreshTokenImportRequestSchema,
} from '../models/refreshTokenImportRequest';
import {
  RegistrationDeleteRequest,
  registrationDeleteRequestSchema,
} from '../models/registrationDeleteRequest';
import {
  RegistrationRequest,
  registrationRequestSchema,
} from '../models/registrationRequest';
import {
  RegistrationResponse,
  registrationResponseSchema,
} from '../models/registrationResponse';
import { SearchRequest, searchRequestSchema } from '../models/searchRequest';
import { SearchResponse, searchResponseSchema } from '../models/searchResponse';
import {
  TwoFactorDisableRequest,
  twoFactorDisableRequestSchema,
} from '../models/twoFactorDisableRequest';
import {
  TwoFactorRecoveryCodeResponse,
  twoFactorRecoveryCodeResponseSchema,
} from '../models/twoFactorRecoveryCodeResponse';
import {
  TwoFactorRequest,
  twoFactorRequestSchema,
} from '../models/twoFactorRequest';
import {
  TwoFactorResponse,
  twoFactorResponseSchema,
} from '../models/twoFactorResponse';
import {
  UserCommentRequest,
  userCommentRequestSchema,
} from '../models/userCommentRequest';
import {
  UserCommentResponse,
  userCommentResponseSchema,
} from '../models/userCommentResponse';
import {
  UserCommentSearchRequest,
  userCommentSearchRequestSchema,
} from '../models/userCommentSearchRequest';
import {
  UserCommentSearchResponse,
  userCommentSearchResponseSchema,
} from '../models/userCommentSearchResponse';
import {
  UserConsentRequest,
  userConsentRequestSchema,
} from '../models/userConsentRequest';
import {
  UserConsentResponse,
  userConsentResponseSchema,
} from '../models/userConsentResponse';
import {
  UserDeleteRequest,
  userDeleteRequestSchema,
} from '../models/userDeleteRequest';
import {
  UserDeleteResponse,
  userDeleteResponseSchema,
} from '../models/userDeleteResponse';
import {
  UserDeleteSingleRequest,
  userDeleteSingleRequestSchema,
} from '../models/userDeleteSingleRequest';
import { UserRequest, userRequestSchema } from '../models/userRequest';
import { UserResponse, userResponseSchema } from '../models/userResponse';
import {
  VerifyEmailRequest,
  verifyEmailRequestSchema,
} from '../models/verifyEmailRequest';
import {
  VerifyEmailResponse,
  verifyEmailResponseSchema,
} from '../models/verifyEmailResponse';
import {
  VerifyRegistrationRequest,
  verifyRegistrationRequestSchema,
} from '../models/verifyRegistrationRequest';
import {
  VerifyRegistrationResponse,
  verifyRegistrationResponseSchema,
} from '../models/verifyRegistrationResponse';
import { optional, string } from '../schema';
import { BaseController } from './baseController';

export class UserController extends BaseController {
  /**
   * Takes an action on a user. The user being actioned is called the "actionee" and the user taking the
   * action is called the "actioner". Both user ids are required in the request object.
   *
   * @param body
   * @return Response from the API call
   */
  async actionUser(
    body?: ActionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ActionResponse>> {
    const req = this.createRequest('POST', '/api/user/action');
    const mapped = req.prepareArgs({
      body: [body, optional(actionRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(actionResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the actions for the user with the given Id that are currently inactive. An inactive
   * action means one that is time based and has been canceled or has expired, or is not time based. OR
   * Retrieves all the actions for the user with the given Id that are currently active. An active action
   * means one that is time based and has not been canceled, and has not ended. OR Retrieves all the
   * actions for the user with the given Id that are currently preventing the User from logging in. OR
   * Retrieves all the actions for the user with the given Id. This will return all time based actions
   * that are active, and inactive as well as non-time based actions.
   *
   * @param userId          The Id of the user to fetch the actions for.
   * @param active
   * @param preventingLogin
   * @return Response from the API call
   */
  async retrieveUserActioningretrieveActionsretrieveActionsPreventingLoginretrieveActiveActionsretrieveInactiveActions(
    userId?: string,
    active?: string,
    preventingLogin?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ActionResponse>> {
    const req = this.createRequest('GET', '/api/user/action');
    const mapped = req.prepareArgs({
      userId: [userId, optional(string())],
      active: [active, optional(string())],
      preventingLogin: [preventingLogin, optional(string())],
    });
    req.query('userId', mapped.userId);
    req.query('active', mapped.active);
    req.query('preventingLogin', mapped.preventingLogin);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(actionResponseSchema, requestOptions);
  }

  /**
   * Adds a comment to the user's account.
   *
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                           request. Only required when there is more than one
   *                                                           tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async commentOnUser(
    xFusionAuthTenantId?: string,
    body?: UserCommentRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserCommentResponse>> {
    const req = this.createRequest('POST', '/api/user/comment');
    const mapped = req.prepareArgs({
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(userCommentRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userCommentResponseSchema, requestOptions);
  }

  /**
   * Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
   *
   * @param userId                (Optional) The Id for the user. If not provided a secure
   *                                                    random UUID will be generated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                    Only required when there is more than one tenant and the API
   *                                                    key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async createUser(
    userId: string,
    xFusionAuthTenantId?: string,
    body?: UserRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(userRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userResponseSchema, requestOptions);
  }

  /**
   * Deletes the user based on the given request (sent to the API as JSON). This permanently deletes all
   * information, metrics, reports and data associated with the user. OR Deletes the user for the given
   * Id. This permanently deletes all information, metrics, reports and data associated with the user. OR
   * Deactivates the user with the given Id.
   *
   * @param userId                The Id of the user to delete (required).
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                                request. Only required when there is more than one
   *                                                                tenant and the API key is not tenant-scoped.
   * @param hardDelete
   * @param body
   * @return Response from the API call
   */
  async deleteUserdeactivateUserWithRequest(
    userId: string,
    xFusionAuthTenantId?: string,
    hardDelete?: string,
    body?: UserDeleteSingleRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      hardDelete: [hardDelete, optional(string())],
      body: [body, optional(userDeleteSingleRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('hardDelete', mapped.hardDelete);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Updates, via PATCH, the user with the given Id.
   *
   * @param userId                The Id of the user to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                    Only required when there is more than one tenant and the API
   *                                                    key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async patchUser(
    userId: string,
    xFusionAuthTenantId?: string,
    body?: UserRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(userRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the members of a family by the unique Family Id.
   *
   * @param familyId              The unique Id of the Family.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveFamilyMembersByFamilyId(
    familyId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FamilyResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      familyId: [familyId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/user/family/${mapped.familyId}`;
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(familyResponseSchema, requestOptions);
  }

  /**
   * Modifies a temporal user action by changing the expiration of the action and optionally adding a
   * comment to the action.
   *
   * @param actionId     The Id of the action to modify. This is technically the user action
   *                                             log id.
   * @param body
   * @return Response from the API call
   */
  async modifyAction(
    actionId: string,
    body?: ActionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ActionResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      actionId: [actionId, string()],
      body: [body, optional(actionRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/action/${mapped.actionId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(actionResponseSchema, requestOptions);
  }

  /**
   * Adds a user to an existing family. The family Id must be specified.
   *
   * @param familyId              The Id of the family.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                      Only required when there is more than one tenant and the API
   *                                                      key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async addUserToFamily(
    familyId: string,
    xFusionAuthTenantId?: string,
    body?: FamilyRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FamilyResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      familyId: [familyId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(familyRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/family/${mapped.familyId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(familyResponseSchema, requestOptions);
  }

  /**
   * Creates a family with the user Id in the request as the owner and sole member of the family. You can
   * optionally specify an Id for the family, if not provided one will be generated.
   *
   * @param familyId              (Optional) The Id for the family. If not provided a secure
   *                                                      random UUID will be generated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                      Only required when there is more than one tenant and the API
   *                                                      key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async createFamily(
    familyId: string,
    xFusionAuthTenantId?: string,
    body?: FamilyRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FamilyResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      familyId: [familyId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(familyRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/family/${mapped.familyId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(familyResponseSchema, requestOptions);
  }

  /**
   * Changes a user's password using the change password Id. This usually occurs after an email has been
   * sent to the user and they clicked on a link to reset their password.  As of version 1.32.2, prefer
   * sending the changePasswordId in the request body. To do this, omit the first parameter, and set the
   * value in the request body.
   *
   * @param changePasswordId The change password Id used to find the user. This value
   *                                                         is generated by FusionAuth once the change password
   *                                                         workflow has been initiated.
   * @param body
   * @return Response from the API call
   */
  async changePassword(
    changePasswordId: string,
    body?: ChangePasswordRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ChangePasswordResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      changePasswordId: [changePasswordId, string()],
      body: [body, optional(changePasswordRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/change-password/${mapped.changePasswordId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(changePasswordResponseSchema, requestOptions);
  }

  /**
   * Check to see if the user must obtain a Trust Token Id in order to complete a change password request.
   * When a user has enabled Two-Factor authentication, before you are allowed to use the Change
   * Password API to change your password, you must obtain a Trust Token by completing a Two-Factor Step-
   * Up authentication.  An HTTP status code of 400 with a general error code of [TrustTokenRequired]
   * indicates that a Trust Token is required to make a POST request to this API.
   *
   * @param changePasswordId The change password Id used to find the user. This value is generated by
   *                                   FusionAuth once the change password workflow has been initiated.
   * @return Response from the API call
   */
  async checkChangePasswordUsingId(
    changePasswordId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      changePasswordId: [changePasswordId, string()],
    });
    req.appendTemplatePath`/api/user/change-password/${mapped.changePasswordId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Cancels the user action.
   *
   * @param actionId     The action Id of the action to cancel.
   * @param body
   * @return Response from the API call
   */
  async cancelAction(
    actionId: string,
    body?: ActionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ActionResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      actionId: [actionId, string()],
      body: [body, optional(actionRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/action/${mapped.actionId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(actionResponseSchema, requestOptions);
  }

  /**
   * Retrieves a single action log (the log of a user action that was taken on a user previously) for the
   * given Id.
   *
   * @param actionId The Id of the action to retrieve.
   * @return Response from the API call
   */
  async retrieveAction(
    actionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ActionResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ actionId: [actionId, string()] });
    req.appendTemplatePath`/api/user/action/${mapped.actionId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(actionResponseSchema, requestOptions);
  }

  /**
   * Changes a user's password using their identity (loginId and password). Using a loginId instead of
   * the changePasswordId bypasses the email verification and allows a password to be changed directly
   * without first calling the #forgotPassword method.
   *
   * @param body
   * @return Response from the API call
   */
  async changePasswordByIdentity(
    body?: ChangePasswordRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/api/user/change-password');
    const mapped = req.prepareArgs({
      body: [body, optional(changePasswordRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Check to see if the user must obtain a Trust Request Id in order to complete a change password
   * request. When a user has enabled Two-Factor authentication, before you are allowed to use the Change
   * Password API to change your password, you must obtain a Trust Request Id by completing a Two-Factor
   * Step-Up authentication.  An HTTP status code of 400 with a general error code of
   * [TrustTokenRequired] indicates that a Trust Token is required to make a POST request to this API. OR
   * Check to see if the user must obtain a Trust Token Id in order to complete a change password request.
   * When a user has enabled Two-Factor authentication, before you are allowed to use the Change
   * Password API to change your password, you must obtain a Trust Token by completing a Two-Factor Step-
   * Up authentication.  An HTTP status code of 400 with a general error code of [TrustTokenRequired]
   * indicates that a Trust Token is required to make a POST request to this API.
   *
   * @param loginId The loginId of the User that you intend to change the password for.
   * @return Response from the API call
   */
  async retrieveUserChangePasswordcheckChangePasswordUsingJWTcheckChangePasswordUsingLoginId(
    loginId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET', '/api/user/change-password');
    const mapped = req.prepareArgs({ loginId: [loginId, optional(string())] });
    req.query('loginId', mapped.loginId);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Updates the user with the given Id. OR Reactivates the user with the given Id.
   *
   * @param userId                The Id of the user to update.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request.
   *                                                    Only required when there is more than one tenant and the API
   *                                                    key is not tenant-scoped.
   * @param reactivate
   * @param body
   * @return Response from the API call
   */
  async updateUserreactivateUser(
    userId: string,
    xFusionAuthTenantId?: string,
    reactivate?: string,
    body?: UserRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      reactivate: [reactivate, optional(string())],
      body: [body, optional(userRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('reactivate', mapped.reactivate);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userResponseSchema, requestOptions);
  }

  /**
   * Re-sends the application registration verification email to the user. OR Generate a new Application
   * Registration Verification Id to be used with the Verify Registration API. This API will not attempt
   * to send an email to the User. This API may be used to collect the verificationId for use with a
   * third party system.
   *
   * @param email                   The email address of the user that needs a new verification email.
   * @param applicationId           The Id of the application to be verified.
   * @param sendVerifyPasswordEmail
   * @return Response from the API call
   */
  async updateUserVerifyRegistrationgenerateRegistrationVerificationIdresendRegistrationVerification(
    email?: string,
    applicationId?: string,
    sendVerifyPasswordEmail?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VerifyRegistrationResponse>> {
    const req = this.createRequest('PUT', '/api/user/verify-registration');
    const mapped = req.prepareArgs({
      email: [email, optional(string())],
      applicationId: [applicationId, optional(string())],
      sendVerifyPasswordEmail: [sendVerifyPasswordEmail, optional(string())],
    });
    req.query('email', mapped.email);
    req.query('applicationId', mapped.applicationId);
    req.query('sendVerifyPasswordEmail', mapped.sendVerifyPasswordEmail);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(verifyRegistrationResponseSchema, requestOptions);
  }

  /**
   * Retrieve a single User consent by Id.
   *
   * @param userConsentId The User consent Id
   * @return Response from the API call
   */
  async retrieveUserConsent(
    userConsentId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserConsentResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userConsentId: [userConsentId, string()],
    });
    req.appendTemplatePath`/api/user/consent/${mapped.userConsentId}`;
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userConsentResponseSchema, requestOptions);
  }

  /**
   * Updates a single User consent by Id.
   *
   * @param userConsentId The User Consent Id
   * @param body
   * @return Response from the API call
   */
  async updateUserConsent(
    userConsentId: string,
    body?: UserConsentRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserConsentResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userConsentId: [userConsentId, string()],
      body: [body, optional(userConsentRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/consent/${mapped.userConsentId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userConsentResponseSchema, requestOptions);
  }

  /**
   * Disable two-factor authentication for a user using a JSON body rather than URL parameters. OR
   * Disable two-factor authentication for a user.
   *
   * @param userId       The Id of the User for which you're disabling two-factor
   *                                                       authentication.
   * @param methodId     The two-factor method identifier you wish to disable
   * @param code         The two-factor code used verify the the caller knows the
   *                                                       two-factor secret.
   * @param body
   * @return Response from the API call
   */
  async deleteUserTwoFactordisableTwoFactordisableTwoFactorWithRequest(
    userId: string,
    methodId?: string,
    code?: string,
    body?: TwoFactorDisableRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      methodId: [methodId, optional(string())],
      code: [code, optional(string())],
      body: [body, optional(twoFactorDisableRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.query('methodId', mapped.methodId);
    req.query('code', mapped.code);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/two-factor/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Re-sends the verification email to the user. If the Application has configured a specific email
   * template this will be used instead of the tenant configuration. OR Re-sends the verification email
   * to the user. OR Generate a new Email Verification Id to be used with the Verify Email API. This API
   * will not attempt to send an email to the User. This API may be used to collect the verificationId
   * for use with a third party system.
   *
   * @param applicationId   The unique Application Id to used to resolve an application specific email
   *                                  template.
   * @param email           The email address of the user that needs a new verification email.
   * @param sendVerifyEmail
   * @return Response from the API call
   */
  async updateUserVerifyEmailgenerateEmailVerificationIdresendEmailVerificationresendEmailVerificationWithApplicationTemplate(
    applicationId?: string,
    email?: string,
    sendVerifyEmail?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<VerifyEmailResponse>> {
    const req = this.createRequest('PUT', '/api/user/verify-email');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, optional(string())],
      email: [email, optional(string())],
      sendVerifyEmail: [sendVerifyEmail, optional(string())],
    });
    req.query('applicationId', mapped.applicationId);
    req.query('email', mapped.email);
    req.query('sendVerifyEmail', mapped.sendVerifyEmail);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(verifyEmailResponseSchema, requestOptions);
  }

  /**
   * Confirms a user's registration.   The request body will contain the verificationId. You may also be
   * required to send a one-time use code based upon your configuration. When  the application is
   * configured to gate a user until their registration is verified, this procedures requires two values
   * instead of one.  The verificationId is a high entropy value and the one-time use code is a low
   * entropy value that is easily entered in a user interactive form. The  two values together are able
   * to confirm a user's registration and mark the user's registration as verified.
   *
   * @param body
   * @return Response from the API call
   */
  async verifyUserRegistration(
    body?: VerifyRegistrationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/api/user/verify-registration');
    const mapped = req.prepareArgs({
      body: [body, optional(verifyRegistrationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Generate two-factor recovery codes for a user. Generating two-factor recovery codes will invalidate
   * any existing recovery codes.
   *
   * @param userId The Id of the user to generate new Two Factor recovery codes.
   * @return Response from the API call
   */
  async generateTwoFactorRecoveryCodes(
    userId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TwoFactorRecoveryCodeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ userId: [userId, string()] });
    req.appendTemplatePath`/api/user/two-factor/recovery-code/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(twoFactorRecoveryCodeResponseSchema, requestOptions);
  }

  /**
   * Retrieve two-factor recovery codes for a user.
   *
   * @param userId The Id of the user to retrieve Two Factor recovery codes.
   * @return Response from the API call
   */
  async retrieveTwoFactorRecoveryCodes(
    userId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TwoFactorRecoveryCodeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ userId: [userId, string()] });
    req.appendTemplatePath`/api/user/two-factor/recovery-code/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(twoFactorRecoveryCodeResponseSchema, requestOptions);
  }

  /**
   * Updates the registration for the user with the given Id and the application defined in the request.
   *
   * @param userId                The Id of the user whose registration is going to be
   *                                                            updated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                            request. Only required when there is more than one
   *                                                            tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async updateRegistration(
    userId: string,
    xFusionAuthTenantId?: string,
    body?: RegistrationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RegistrationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(registrationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/registration/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(registrationResponseSchema, requestOptions);
  }

  /**
   * Removes a user from the family with the given id.
   *
   * @param familyId              The Id of the family to remove the user from.
   * @param userId                The Id of the user to remove from the family.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async removeUserFromFamily(
    familyId: string,
    userId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      familyId: [familyId, string()],
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/user/family/${mapped.familyId}/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Retrieves all the families that a user belongs to.
   *
   * @param userId                The User's id
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveFamilies(
    userId?: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FamilyResponse>> {
    const req = this.createRequest('GET', '/api/user/family');
    const mapped = req.prepareArgs({
      userId: [userId, optional(string())],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('userId', mapped.userId);
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(familyResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the comments for the user with the given Id.
   *
   * @param userId                The Id of the user.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveUserComments(
    userId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserCommentResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/user/comment/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userCommentResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the consents for a User.
   *
   * @param userId The User's Id
   * @return Response from the API call
   */
  async retrieveUserConsents(
    userId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserConsentResponse>> {
    const req = this.createRequest('GET', '/api/user/consent');
    const mapped = req.prepareArgs({ userId: [userId, optional(string())] });
    req.query('userId', mapped.userId);
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userConsentResponseSchema, requestOptions);
  }

  /**
   * Retrieves all the children for the given parent email address.
   *
   * @param parentEmail The email of the parent.
   * @return Response from the API call
   */
  async retrievePendingChildren(
    parentEmail?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PendingResponse>> {
    const req = this.createRequest('GET', '/api/user/family/pending');
    const mapped = req.prepareArgs({
      parentEmail: [parentEmail, optional(string())],
    });
    req.query('parentEmail', mapped.parentEmail);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(pendingResponseSchema, requestOptions);
  }

  /**
   * Retrieves the last number of login records for a user. OR Retrieves the last number of login records.
   *
   * @param userId The Id of the user.
   * @param offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param limit  (Optional, defaults to 10) The number of records to retrieve.
   * @return Response from the API call
   */
  async retrieveUserRecentLoginretrieveRecentLoginss(
    userId?: string,
    offset?: string,
    limit?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RecentLoginResponse>> {
    const req = this.createRequest('GET', '/api/user/recent-login');
    const mapped = req.prepareArgs({
      userId: [userId, optional(string())],
      offset: [offset, optional(string())],
      limit: [limit, optional(string())],
    });
    req.query('userId', mapped.userId);
    req.query('offset', mapped.offset);
    req.query('limit', mapped.limit);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(recentLoginResponseSchema, requestOptions);
  }

  /**
   * Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web
   * Token (JWT) for authentication. OR Retrieves the user by a verificationId. The intended use of this
   * API is to retrieve a user after the forgot password workflow has been initiated and you may not know
   * the user's email or username. OR Retrieves the user for the given username. OR Retrieves the user
   * for the loginId. The loginId can be either the username or the email. OR Retrieves the user for the
   * given email. OR Retrieves the user by a change password Id. The intended use of this API is to
   * retrieve a user after the forgot password workflow has been initiated and you may not know the
   * user's email or username.
   *
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @param verificationId        The unique verification Id that has been set on the user object.
   * @param username              The username of the user.
   * @param loginId               The email or username of the user.
   * @param email                 The email of the user.
   * @param changePasswordId      The unique change password Id that was sent via email or returned by the
   *                                        Forgot Password API.
   * @return Response from the API call
   */
  async retrieveUserByChangePasswordIdByEmailByLoginIdByUsernameByVerificationIdUsingJWT(
    xFusionAuthTenantId?: string,
    verificationId?: string,
    username?: string,
    loginId?: string,
    email?: string,
    changePasswordId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserResponse>> {
    const req = this.createRequest('GET', '/api/user');
    const mapped = req.prepareArgs({
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      verificationId: [verificationId, optional(string())],
      username: [username, optional(string())],
      loginId: [loginId, optional(string())],
      email: [email, optional(string())],
      changePasswordId: [changePasswordId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.query('verificationId', mapped.verificationId);
    req.query('username', mapped.username);
    req.query('loginId', mapped.loginId);
    req.query('email', mapped.email);
    req.query('changePasswordId', mapped.changePasswordId);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ bearerAuth: true }]);
    return req.callAsJson(userResponseSchema, requestOptions);
  }

  /**
   * Retrieves the users for the given ids. If any Id is invalid, it is ignored.
   *
   * @param ids The user ids to search for.
   * @return Response from the API call
   */
  async searchUsersByIds(
    ids?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchResponse>> {
    const req = this.createRequest('GET', '/api/user/search');
    const mapped = req.prepareArgs({ ids: [ids, optional(string())] });
    req.query('ids', mapped.ids);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(searchResponseSchema, requestOptions);
  }

  /**
   * Retrieves the user for the given Id.
   *
   * @param userId                The Id of the user.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveUser(
    userId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/user/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userResponseSchema, requestOptions);
  }

  /**
   * Updates, via PATCH, a single User consent by Id.
   *
   * @param userConsentId The User Consent Id
   * @param body
   * @return Response from the API call
   */
  async patchUserConsent(
    userConsentId: string,
    body?: UserConsentRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserConsentResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      userConsentId: [userConsentId, string()],
      body: [body, optional(userConsentRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/consent/${mapped.userConsentId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userConsentResponseSchema, requestOptions);
  }

  /**
   * Deletes the user registration for the given user and application along with the given JSON body that
   * contains the event information. OR Deletes the user registration for the given user and application.
   *
   * @param userId                The Id of the user whose registration is being
   *                                                                  deleted.
   * @param applicationId         The Id of the application to remove the
   *                                                                  registration for.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this
   *                                                                  API request. Only required when there is more
   *                                                                  than one tenant and the API key is not tenant-
   *                                                                  scoped.
   * @param body
   * @return Response from the API call
   */
  async deleteUserRegistrationdeleteRegistrationdeleteRegistrationWithRequest(
    userId: string,
    applicationId: string,
    xFusionAuthTenantId?: string,
    body?: RegistrationDeleteRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(registrationDeleteRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/registration/${mapped.userId}/${mapped.applicationId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Retrieves the user registration for the user with the given Id and the given application id.
   *
   * @param userId                The Id of the user.
   * @param applicationId         The Id of the application.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API request. Only required
   *                                        when there is more than one tenant and the API key is not tenant-scoped.
   * @return Response from the API call
   */
  async retrieveRegistration(
    userId: string,
    applicationId: string,
    xFusionAuthTenantId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RegistrationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      applicationId: [applicationId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
    });
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.appendTemplatePath`/api/user/registration/${mapped.userId}/${mapped.applicationId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(registrationResponseSchema, requestOptions);
  }

  /**
   * Enable two-factor authentication for a user.
   *
   * @param userId       The Id of the user to enable two-factor authentication.
   * @param body
   * @return Response from the API call
   */
  async enableTwoFactor(
    userId: string,
    body?: TwoFactorRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TwoFactorResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      body: [body, optional(twoFactorRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/two-factor/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(twoFactorResponseSchema, requestOptions);
  }

  /**
   * Administratively verify a user's email address. Use this method to bypass email verification for the
   * user.  The request body will contain the userId to be verified. An API key is required when sending
   * the userId in the request body. OR Confirms a user's email address.   The request body will contain
   * the verificationId. You may also be required to send a one-time use code based upon your
   * configuration. When  the tenant is configured to gate a user until their email address is verified,
   * this procedures requires two values instead of one.  The verificationId is a high entropy value and
   * the one-time use code is a low entropy value that is easily entered in a user interactive form. The
   * two values together are able to confirm a user's email address and mark the user's email address as
   * verified.
   *
   * @param body
   * @return Response from the API call
   */
  async createUserVerifyEmailverifyEmailAddressverifyEmailAddressByUserId(
    body?: VerifyEmailRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/api/user/verify-email');
    const mapped = req.prepareArgs({
      body: [body, optional(verifyEmailRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Sends out an email to a parent that they need to register and create a family or need to log in and
   * add a child to their existing family.
   *
   * @param body
   * @return Response from the API call
   */
  async sendFamilyRequestEmail(
    body?: FamilyEmailRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/api/user/family/request');
    const mapped = req.prepareArgs({
      body: [body, optional(familyEmailRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Creates a single User consent.
   *
   * @param userConsentId (Optional) The Id for the User consent. If not provided a
   *                                                   secure random UUID will be generated.
   * @param body
   * @return Response from the API call
   */
  async createUserConsent(
    userConsentId: string,
    body?: UserConsentRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserConsentResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userConsentId: [userConsentId, string()],
      body: [body, optional(userConsentRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/consent/${mapped.userConsentId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userConsentResponseSchema, requestOptions);
  }

  /**
   * Revokes a single User consent by Id.
   *
   * @param userConsentId The User Consent Id
   * @return Response from the API call
   */
  async revokeUserConsent(
    userConsentId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userConsentId: [userConsentId, string()],
    });
    req.appendTemplatePath`/api/user/consent/${mapped.userConsentId}`;
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Deletes the users with the given ids, or users matching the provided JSON query or queryString. The
   * order of preference is ids, query and then queryString, it is recommended to only provide one of the
   * three for the request.  This method can be used to deactivate or permanently delete (hard-delete)
   * users based upon the hardDelete boolean in the request body. Using the dryRun parameter you may also
   * request the result of the action without actually deleting or deactivating any users. OR Deactivates
   * the users with the given ids.
   *
   * @param userIds      The ids of the users to deactivate.
   * @param dryRun
   * @param hardDelete
   * @param body
   * @return Response from the API call
   */
  async deleteUserBulkdeactivateUsersByIdsdeleteUsersByQuery(
    userIds?: string,
    dryRun?: string,
    hardDelete?: string,
    body?: UserDeleteRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserDeleteResponse>> {
    const req = this.createRequest('DELETE', '/api/user/bulk');
    const mapped = req.prepareArgs({
      userIds: [userIds, optional(string())],
      dryRun: [dryRun, optional(string())],
      hardDelete: [hardDelete, optional(string())],
      body: [body, optional(userDeleteRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.query('userIds', mapped.userIds);
    req.query('dryRun', mapped.dryRun);
    req.query('hardDelete', mapped.hardDelete);
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userDeleteResponseSchema, requestOptions);
  }

  /**
   * Begins the forgot password sequence, which kicks off an email to the user so that they can reset
   * their password.
   *
   * @param body
   * @return Response from the API call
   */
  async forgotPassword(
    body?: ForgotPasswordRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ForgotPasswordResponse>> {
    const req = this.createRequest('POST', '/api/user/forgot-password');
    const mapped = req.prepareArgs({
      body: [body, optional(forgotPasswordRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(forgotPasswordResponseSchema, requestOptions);
  }

  /**
   * Bulk imports refresh tokens. This request performs minimal validation and runs batch inserts of
   * refresh tokens with the expectation that each token represents a user that already exists and is
   * registered for the corresponding FusionAuth Application. This is done to increases the insert
   * performance.  Therefore, if you encounter an error due to a database key violation, the response
   * will likely offer a generic explanation. If you encounter an error, you may optionally enable
   * additional validation to receive a JSON response body with specific validation errors. This will
   * slow the request down but will allow you to identify the cause of the failure. See the
   * validateDbConstraints request parameter.
   *
   * @param body
   * @return Response from the API call
   */
  async importRefreshTokens(
    body?: RefreshTokenImportRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/api/user/refresh-token/import');
    const mapped = req.prepareArgs({
      body: [body, optional(refreshTokenImportRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Bulk imports users. This request performs minimal validation and runs batch inserts of users with
   * the expectation that each user does not yet exist and each registration corresponds to an existing
   * FusionAuth Application. This is done to increases the insert performance.  Therefore, if you
   * encounter an error due to a database key violation, the response will likely offer a generic
   * explanation. If you encounter an error, you may optionally enable additional validation to receive a
   * JSON response body with specific validation errors. This will slow the request down but will allow
   * you to identify the cause of the failure. See the validateDbConstraints request parameter.
   *
   * @param body
   * @return Response from the API call
   */
  async importUsers(
    body?: ImportRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/api/user/import');
    const mapped = req.prepareArgs({
      body: [body, optional(importRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Updates, via PATCH, the registration for the user with the given Id and the application defined in
   * the request.
   *
   * @param userId                The Id of the user whose registration is going to be
   *                                                            updated.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                            request. Only required when there is more than one
   *                                                            tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async patchRegistration(
    userId: string,
    xFusionAuthTenantId?: string,
    body?: RegistrationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RegistrationResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(registrationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/registration/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(registrationResponseSchema, requestOptions);
  }

  /**
   * Registers a user for an application. If you provide the User and the UserRegistration object on this
   * request, it will create the user as well as register them for the application. This is called a Full
   * Registration. However, if you only provide the UserRegistration object, then the user must already
   * exist and they will be registered for the application. The user Id can also be provided and it will
   * either be used to look up an existing user or it will be used for the newly created User.
   *
   * @param userId                (Optional) The Id of the user being registered for the
   *                                                            application and optionally created.
   * @param xFusionAuthTenantId   The unique Id of the tenant used to scope this API
   *                                                            request. Only required when there is more than one
   *                                                            tenant and the API key is not tenant-scoped.
   * @param body
   * @return Response from the API call
   */
  async register(
    userId: string,
    xFusionAuthTenantId?: string,
    body?: RegistrationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RegistrationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      xFusionAuthTenantId: [xFusionAuthTenantId, optional(string())],
      body: [body, optional(registrationRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.header('X-FusionAuth-TenantId', mapped.xFusionAuthTenantId);
    req.json(mapped.body);
    req.appendTemplatePath`/api/user/registration/${mapped.userId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(registrationResponseSchema, requestOptions);
  }

  /**
   * Searches user comments with the specified criteria and pagination.
   *
   * @param body
   * @return Response from the API call
   */
  async searchUserComments(
    body?: UserCommentSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserCommentSearchResponse>> {
    const req = this.createRequest('POST', '/api/user/comment/search');
    const mapped = req.prepareArgs({
      body: [body, optional(userCommentSearchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(userCommentSearchResponseSchema, requestOptions);
  }

  /**
   * Retrieves the users for the given search criteria and pagination.
   *
   * @param body
   * @return Response from the API call
   */
  async searchUsersByQuery(
    body?: SearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchResponse>> {
    const req = this.createRequest('POST', '/api/user/search');
    const mapped = req.prepareArgs({
      body: [body, optional(searchRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(searchResponseSchema, requestOptions);
  }
}
