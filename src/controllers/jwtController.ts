/**
 * FusionAuth APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiError } from '@apimatic/core';
import { ApiResponse, RequestOptions } from '../core';
import { ErrorsError } from '../errors/errorsError';
import {
  IdentityProviderLoginRequest,
  identityProviderLoginRequestSchema,
} from '../models/identityProviderLoginRequest';
import { IssueResponse, issueResponseSchema } from '../models/issueResponse';
import {
  JWTRefreshResponse,
  jWTRefreshResponseSchema,
} from '../models/jWTRefreshResponse';
import { JWTVendRequest, jWTVendRequestSchema } from '../models/jWTVendRequest';
import {
  JWTVendResponse,
  jWTVendResponseSchema,
} from '../models/jWTVendResponse';
import { LoginResponse, loginResponseSchema } from '../models/loginResponse';
import {
  PublicKeyResponse,
  publicKeyResponseSchema,
} from '../models/publicKeyResponse';
import { RefreshRequest, refreshRequestSchema } from '../models/refreshRequest';
import {
  RefreshTokenResponse,
  refreshTokenResponseSchema,
} from '../models/refreshTokenResponse';
import {
  RefreshTokenRevokeRequest,
  refreshTokenRevokeRequestSchema,
} from '../models/refreshTokenRevokeRequest';
import {
  ValidateResponse,
  validateResponseSchema,
} from '../models/validateResponse';
import { optional, string } from '../schema';
import { BaseController } from './baseController';

export class JwtController extends BaseController {
  /**
   * Retrieves a single refresh token by unique Id. This is not the same thing as the string value of the
   * refresh token. If you have that, you already have what you need.
   *
   * @param tokenId The Id of the token.
   * @return Response from the API call
   */
  async retrieveRefreshTokenById(
    tokenId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RefreshTokenResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ tokenId: [tokenId, string()] });
    req.appendTemplatePath`/api/jwt/refresh/${mapped.tokenId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(refreshTokenResponseSchema, requestOptions);
  }

  /**
   * Retrieves the refresh tokens that belong to the user with the given Id.
   *
   * @param userId The Id of the user.
   * @return Response from the API call
   */
  async retrieveRefreshTokens(
    userId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RefreshTokenResponse>> {
    const req = this.createRequest('GET', '/api/jwt/refresh');
    const mapped = req.prepareArgs({ userId: [userId, optional(string())] });
    req.query('userId', mapped.userId);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(refreshTokenResponseSchema, requestOptions);
  }

  /**
   * Retrieves the Public Key configured for verifying the JSON Web Tokens (JWT) issued by the Login API
   * by the Application Id. OR Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by
   * the key Id (kid).
   *
   * @param applicationId The Id of the Application for which this key is used.
   * @param keyId         The Id of the public key (kid).
   * @return Response from the API call
   */
  async retrieveJwtPublicKeyretrieveJWTPublicKeyretrieveJWTPublicKeyByApplicationId(
    applicationId?: string,
    keyId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PublicKeyResponse>> {
    const req = this.createRequest('GET', '/api/jwt/public-key');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, optional(string())],
      keyId: [keyId, optional(string())],
    });
    req.query('applicationId', mapped.applicationId);
    req.query('keyId', mapped.keyId);
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(publicKeyResponseSchema, requestOptions);
  }

  /**
   * Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token
   * is properly signed and not expired. <p> This API may be used to verify the JWT as well as decode the
   * encoded JWT into human readable identity claims.
   *
   * @return Response from the API call
   */
  async validateJWT(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ValidateResponse>> {
    const req = this.createRequest('GET', '/api/jwt/validate');
    req.defaultToError(ApiError, 'Error');
    req.authenticate([{ bearerAuth: true }]);
    return req.callAsJson(validateResponseSchema, requestOptions);
  }

  /**
   * Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is
   * valid. A valid access token is properly signed and not expired. <p> This API may be used in an SSO
   * configuration to issue new tokens for another application after the user has obtained a valid token
   * from authentication.
   *
   * @param applicationId The Application Id for which you are requesting a new access token be issued.
   * @param refreshToken  (Optional) An existing refresh token used to request a refresh token in addition
   *                                to a JWT in the response. <p>The target application represented by the
   *                                applicationId request parameter must have refresh tokens enabled in order to
   *                                receive a refresh token in the response.</p>
   * @return Response from the API call
   */
  async issueJWT(
    applicationId?: string,
    refreshToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<IssueResponse>> {
    const req = this.createRequest('GET', '/api/jwt/issue');
    const mapped = req.prepareArgs({
      applicationId: [applicationId, optional(string())],
      refreshToken: [refreshToken, optional(string())],
    });
    req.query('applicationId', mapped.applicationId);
    req.query('refreshToken', mapped.refreshToken);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ bearerAuth: true }]);
    return req.callAsJson(issueResponseSchema, requestOptions);
  }

  /**
   * Exchange a refresh token for a new JWT.
   *
   * @param body
   * @return Response from the API call
   */
  async exchangeRefreshTokenForJWT(
    body?: RefreshRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<JWTRefreshResponse>> {
    const req = this.createRequest('POST', '/api/jwt/refresh');
    const mapped = req.prepareArgs({
      body: [body, optional(refreshRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(jWTRefreshResponseSchema, requestOptions);
  }

  /**
   * Revokes refresh tokens using the information in the JSON body. The handling for this method is the
   * same as the revokeRefreshToken method and is based on the information you provide in the
   * RefreshDeleteRequest object. See that method for additional information. OR Revoke all refresh
   * tokens that belong to a user by user Id for a specific application by applicationId. OR Revoke all
   * refresh tokens that belong to a user by user Id. OR Revoke all refresh tokens that belong to an
   * application by applicationId. OR Revokes a single refresh token by using the actual refresh token
   * value. This refresh token value is sensitive, so  be careful with this API request. OR Revokes
   * refresh tokens.  Usage examples:   - Delete a single refresh token, pass in only the token.
   * revokeRefreshToken(token)    - Delete all refresh tokens for a user, pass in only the userId.
   * revokeRefreshToken(null, userId)    - Delete all refresh tokens for a user for a specific
   * application, pass in both the userId and the applicationId.       revokeRefreshToken(null, userId,
   * applicationId)    - Delete all refresh tokens for an application       revokeRefreshToken(null, null,
   * applicationId)  Note: <code>null</code> may be handled differently depending upon the programming
   * language.  See also: (method names may vary by language... but you'll figure it out)   -
   * revokeRefreshTokenById  - revokeRefreshTokenByToken  - revokeRefreshTokensByUserId  -
   * revokeRefreshTokensByApplicationId  - revokeRefreshTokensByUserIdForApplication
   *
   * @param userId        The unique Id of the user that you want to delete all
   *                                                          refresh tokens for.
   * @param applicationId The unique Id of the application that you want to delete
   *                                                          refresh tokens for.
   * @param token         The refresh token to delete.
   * @param body
   * @return Response from the API call
   */
  async deleteJwtRefreshrevokeRefreshTokenrevokeRefreshTokenByTokenrevokeRefreshTokensByApplicationIdrevokeRefreshTokensByUserIdrevokeRefreshTokensByUserIdForApplicationrevokeRefreshTokensWithRequest(
    userId?: string,
    applicationId?: string,
    token?: string,
    body?: RefreshTokenRevokeRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE', '/api/jwt/refresh');
    const mapped = req.prepareArgs({
      userId: [userId, optional(string())],
      applicationId: [applicationId, optional(string())],
      token: [token, optional(string())],
      body: [body, optional(refreshTokenRevokeRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.query('userId', mapped.userId);
    req.query('applicationId', mapped.applicationId);
    req.query('token', mapped.token);
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
   *
   * @param body
   * @return Response from the API call
   */
  async reconcileJWT(
    body?: IdentityProviderLoginRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LoginResponse>> {
    const req = this.createRequest('POST', '/api/jwt/reconcile');
    const mapped = req.prepareArgs({
      body: [body, optional(identityProviderLoginRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(loginResponseSchema, requestOptions);
  }

  /**
   * Revokes a single refresh token by the unique Id. The unique Id is not sensitive as it cannot be used
   * to obtain another JWT.
   *
   * @param tokenId The unique Id of the token to delete.
   * @return Response from the API call
   */
  async revokeRefreshTokenById(
    tokenId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ tokenId: [tokenId, string()] });
    req.appendTemplatePath`/api/jwt/refresh/${mapped.tokenId}`;
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.call(requestOptions);
  }

  /**
   * It's a JWT vending machine!  Issue a new access token (JWT) with the provided claims in the request.
   * This JWT is not scoped to a tenant or user, it is a free form  token that will contain what claims
   * you provide. <p> The iat, exp and jti claims will be added by FusionAuth, all other claims must be
   * provided by the caller.  If a TTL is not provided in the request, the TTL will be retrieved from the
   * default Tenant or the Tenant specified on the request either  by way of the X-FusionAuth-TenantId
   * request header, or a tenant scoped API key.
   *
   * @param body
   * @return Response from the API call
   */
  async vendJWT(
    body?: JWTVendRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<JWTVendResponse>> {
    const req = this.createRequest('POST', '/api/jwt/vend');
    const mapped = req.prepareArgs({
      body: [body, optional(jWTVendRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.defaultToError(ErrorsError, 'Error');
    req.authenticate([{ apiKeyAuth: true }]);
    return req.callAsJson(jWTVendResponseSchema, requestOptions);
  }
}
